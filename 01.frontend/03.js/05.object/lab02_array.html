<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>lab02_array.html</title>
</head>
<body>
    <script>
        // 배열
        // 생성
        let array1 = [1, 2, 3];
        console.log(array1);

        let array2 = new Array('a','b','c');
        //console.log(array2);

        // 요소 조회
        console.log(array1[0]);

        // 배열 길이
        console.log(array1.length);

        // 배열의 마지막 요소만 출력
        console.log(array1.length);
        console.log(array1[2])

        console.log(array1[array1.length - 1]);

        // 배열 요소 추가
        let array3 = [1, 2, 3, 4, 5];

        array3.push(6,7);
        array3.unshift(0); // 맨 앞에 추가
        console.log(array3);

        array3.pop(); //맨 뒤에 추가
        array3.shift(0); //맨 앞에 삭제
        console.log(array3);

        array3.slice(2, 4);
        console.log(array3);
        
        //slice
        console.log(array3.slice(2));
        console.log(array3.slice(2, 4));
        
        // splice
        console.log(array3.splice(2));
        console.log(array3.splice(2, 1));

        // 반복
        let array4 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 12, 34, 4, 1 ,54 ,1,4 ,54 ,4, 6,4 ,4, 2];
        for(let i = 0; i < array4.length; i++) {
            console.log(array4[i]*5);
        }

        for(let i of array4){
            console.log(i);
        }

        array4.forEach(function(i){
            console.log(i);
        });

        // JS Engine (call stack(원시타입, 변수, 스코프, this 등) + heap(객체(참조타입)))
        // call stack

        // let a = 1;
        // let b = a;

        // console.log(b); //1

        // b = 2;
        // console.log(b);

        // a = 3;
        // console.log(a);

        let a = 1;
        let b = a;
        console.log(a == b); //true

        //이미 데이터가 있으면 그거를 이용함.

        //객체타입일 때 call stack의 값에 주소를 저장하고 heap의 주소 부분에 call stack의 값들어가고 heap의 값에 값이 들어간다.
        //heap
        //얕은복사
        let arr = [1,2,3];
        let shallowArr = arr;
        let arr2 = [1,2,3];

        console.log(arr == shallowArr);
        console.log(arr === shallowArr); // === 타입까지 비교



        console.log(arr == arr2); // 비교할 때 call stack의 주소로 함. fasle
        console.log(arr === arr2);  //fasle

        //똑같은 값을 가지고 있더라도 다른 객체로 인식

        arr[0] = 0;
        console.log(arr);
        console.log(shallowArr);
        console.log(arr2);

        //깊은복사
        let deepArr1 = arr.slice(); //명령어가 실행되어서 깊은 복사가 되는 것.
        let deepArr2 = arr.concat();
        let deepArr3 = Array.from(arr);

        console.log(arr == deepArr1); //fasle
        console.log(arr == deepArr2); //fasle
        console.log(arr == deepArr3); //fasle
        // 새로운 객체를 하나 더 만듬. 원본을 만듬.

        // ? test[0] 이라는 코드를 어떻게 해석하느냐?
            // [ ] 사이의 0 은 index 값, 그렇다면 arr[0]은 어떤값? 객체? 아니면?

            // let test = [1, 'b', [1, 2, 3]]
            // console.log(test);
            // console.log(typeof(test));
            // console.log('-----');
            // console.log(test[0]);
            // console.log(typeof(test[0]));
            // console.log(typeof(test[1]));
            // console.log(typeof(test[2]));

            // for(let i = 0; i < test.length; i++) {
            //     console.log(test[i]*5);












    </script>
</body>
</html>