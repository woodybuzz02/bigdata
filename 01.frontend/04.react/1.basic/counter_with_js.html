<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <!-- 앞으로 우리가 작성할 react code(app)는 이 <div> 내부에 렌더링 됨 -->
    <div id="root"></div> <!--앞으로 element라고 할 거임.-->
    <button class="btn">Increase</button>
    <script>
        // Vanilla JS

        // id가 root인 엘리먼트 내부에 <p>count</p>를 계속 덮어씌움(갱신)

        // document.getElementById('root').innerHTML=`<p>count</p>`;
        // addEventListener(click) 내가 작성하던 것...
        
        // const root = document.getElementById('root');
        // const button = document.querySelector('button');
        
        // let count = 0;
        // root.innerHTML = `<p>0</p>` ;
        
        // button.addEventListener('click', () = > {
            //     root.innerHTML = `<p>${++count}</p>`;
            // });
            
        //->//innerHTML, count 변수, <p>count</p>를 갱신하는 코드를 함수로 작성
        // increase 버튼이 클릭되었을 때마다 특정 함수가 호출되면서 <p>count</p>를 갱신

        // 초기 값
        const component ={
            count: 0,
            updateElement() {
                return `<p>${this.count}</p>`; //`<p>${this.count}</p>` 컴포넌트
            }
        };

        //console.log(component.updateElement());

        //초기 화면을 rendering해주는 함수
        function render(component, element) {
            element.innerHTML = component.updateElement();
        };

        console.log('초기 화면 rendering');
        const rootElement = document.getElementById('root');
        render(component, rootElement);

        const button = document.querySelector('button');
        button.addEventListener('click', () => {
            // 특정 이벤트(button click)에 의해 component 값(count)의 상태(state)가 바뀌면 바뀐 상태 값으로 다시 rendering함.
            component.count += 1 ;

            // 새로 업데이트된 component로 다시 렌더링(re-rendering)
            render(component, rootElement);

        });

    </script>
</body>
</html>